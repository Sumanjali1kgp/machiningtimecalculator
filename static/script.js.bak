// Global variables
let materials = [];
let operations = {};  // Map operation IDs to operation names
let processCount = 0;
let materialSelect, operationSelect, formContainer, operationList, addProcessBtn;

// Global functions
function removeEntry(id) {
    const entry = document.getElementById(id);
    if (entry) {
        entry.remove();
        calculateTotalTime();
    }
}

document.addEventListener('DOMContentLoaded', initApp);

async function initApp() {
    materialSelect = document.getElementById('materialSelect');
    operationSelect = document.getElementById('operationSelect');
    formContainer = document.getElementById('formContainer');
    operationList = document.getElementById('operationList');

    materialSelect.addEventListener('change', onMaterialSelected);
    operationSelect.addEventListener('change', addProcess);

    await Promise.all([fetchAndPopulateMaterials(), fetchAndPopulateOperations()]);
}

// Operation display names
const operationDisplayNames = {
    'facing': 'Facing',
    'turning': 'Turning',
    'drilling': 'Drilling',
    'boring': 'Boring',
    'threading': 'Threading',
    'knurling': 'Knurling',
    'parting': 'Parting',
    'grooving': 'Grooving',
    'milling': 'Milling',
    'slabmilling': 'Slab Milling',
    'facemilling': 'Face Milling',
    'endmilling': 'End Milling',
    'idle': 'Idle Time',
    'reaming': 'Reaming',

};

// Helper function to format numbers with specified decimal places
function formatNumber(num, decimals = 2) {
    if (num === null || num === undefined) return 'N/A';
    return typeof num === 'number' ? num.toFixed(decimals) : num;
}


// Fetch and populate materials from API
async function fetchAndPopulateMaterials() {
    try {
        const response = await fetch('/api/materials');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const materialsData = await response.json();
        
        materialSelect.innerHTML = '<option value="">Select Material</option>';
        materialsData.forEach(material => {
            const option = document.createElement('option');
            option.value = material.material_id;
            option.textContent = material.material_name;  // Add this line to display the material name
            materialSelect.appendChild(option);
        });
    } catch (error) {
        console.error('Error loading materials:', error);
        alert('Failed to load materials. Please try again later.');
    }
}

// Fetch and populate operations from API
async function fetchAndPopulateOperations() {
    try {
        const response = await fetch('/api/operations');
        const data = await response.json();
        operationSelect.innerHTML = '<option value="">Select Operation</option>';

        data.forEach(op => {
            if (op && op.operation_id) {
                const option = new Option(op.operation_name, op.operation_id);
                operationSelect.add(option);
                operations[op.operation_id] = op.operation_name.toLowerCase();
            }
        });
    } catch (error) {
        loadDefaultOperations();
    }
}
// Load default operations if API fails
function loadDefaultOperations() {
    const defaultOperations = [
        { operation_id: 1, operation_name: 'Facing' },
        { operation_id: 2, operation_name: 'Turning' },
        { operation_id: 3, operation_name: 'Drilling' },
        { operation_id: 4, operation_name: 'Boring' },
        { operation_id: 5, operation_name: 'Reaming' },
        { operation_id: 6, operation_name: 'Threading' },
        { operation_id: 7, operation_name: 'Knurling' },
        { operation_id: 8, operation_name: 'Parting' },
        { operation_id: 9, operation_name: 'Grooving' },
        { operation_id: 10, operation_name: 'Idle' }
    ];
    
    operationSelect.innerHTML = '<option value="">Select Operation</option>';
    defaultOperations.forEach(op => {
        const option = new Option(op.operation_name, op.operation_id);
        operationSelect.add(option);
        operations[op.operation_id] = op.operation_name.toLowerCase();
    });
}

// Validate that a material is selected
function onMaterialSelected() {
    const selectedMaterial = materialSelect.value;
    const errorElement = document.getElementById('materialError');

    if (!selectedMaterial) {
        errorElement.textContent = 'Please select a material';
        return false;
    }

    errorElement.textContent = '';
    return true;
}

// Called whenever material changes; optionally triggers recalculation for this process
function updateMaterial(processId, materialId) {
    console.log(`Updating material for ${processId} to materialId: ${materialId}`);

    const entry = document.getElementById(processId);
    if (!entry) return;

    const operationType = entry.querySelector('input[name="operation"]')?.value;
    if (operationType) {
        // Trigger recalculation for this operation if material changed
        calculateOperation(processId, operationType);
    }
}

// Add a new process entry to the list
function addProcess() {
    console.log('addProcess called');

    if (!operationSelect) {
        console.error('Operation select element not found');
        return;
    }

    const selectedOption = operationSelect.options[operationSelect.selectedIndex];
    if (!selectedOption || !selectedOption.value) {
        alert('Please select an operation first.');
        return;
    }

    // Get operation info
    const operationName = selectedOption.text.trim();
    const operationId = operationSelect.value; // Get the selected operation ID
    const operationType = operations[operationId] || operationName.toLowerCase();
    
    // Create simple process ID using just the operation ID
    const processId = `process_${operationId}`;
    
    // Remove any existing process with the same operation ID
    const existingProcess = document.getElementById(processId);
    if (existingProcess) {
        existingProcess.remove();
    }
    
    console.log(`Adding process: ${operationName} (${operationType}), Operation ID: ${operationId}`);

    // Create container for the operation entry
    const operationEntry = document.createElement('div');
    operationEntry.className = 'operation-entry';
    operationEntry.id = processId;
    operationEntry.dataset.operationType = operationType;
    operationEntry.dataset.operationId = operationId;

    // Header with title and remove button
    const header = document.createElement('div');
    header.className = 'operation-header';
    header.innerHTML = `
        <h3>${operationName} Operation</h3>
        <button class="btn-remove" onclick="removeEntry('${processId}')" title="Remove process">
            <i class="fas fa-times"></i>
        </button>
    `;

    // Form container
    const form = document.createElement('div');
    form.className = 'operation-form';

    // Generate operation-specific inputs
    const formHTML = generateOperationForm(operationType, processId);
    if (!formHTML) {
        console.error('No form template found for operation type:', operationType);
        return;
    }
    form.innerHTML = formHTML;

    // Assemble the new entry
    operationEntry.appendChild(header);
    operationEntry.appendChild(form);

    // Append to the operation list
    if (!operationList) {
        operationList = document.getElementById('operationList');
        if (!operationList) {
            console.error('Operation list container not found');
            return;
        }
    }
    operationList.appendChild(operationEntry);

    // Show action buttons if this is the first process
    const actionButtons = document.querySelector('.action-buttons');    
    if (actionButtons && actionButtons.style.display === 'none') {
        actionButtons.style.display = 'block';
    }

    // Reset the select dropdown
    operationSelect.selectedIndex = 0;

    // Scroll to the new process for better UX
    operationEntry.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

    console.log('Process successfully added.');
}

/**
 * Generate form HTML based on operation type
 * @param {string} operationType - The type of operation (e.g., 'facing', 'turning')
 * @param {string} entryId - Unique ID for the form elements
 * @returns {string} HTML string for the operation form
 */
function generateOperationForm(operationType, entryId) {
    if (!operationType) {
        console.error('No operation type provided');
        return '';
    }
    
    // Convert to lowercase for case-insensitive comparison
    const opType = operationType.toLowerCase();
    

   // Updated formGroup helper
const formGroup = (label, name, opts = {}) => {
    const { 
      type = 'text',
      step = '',
      min = '',
      value = '',
      required = true,
      options = []
    } = opts;
    const inputId = `${entryId}_${name}`;

    let input = '';
    if (type === 'select') {
        const optionTags = options
            .map(opt => `<option value="${opt.value}">${opt.text || opt.label || opt.value}</option>`)
            .join('');
        input = `
          <select class="form-control" id="${inputId}" name="${name}" ${required ? 'required' : ''}>
              <option value="">-- Select --</option>${optionTags}
          </select>`;
    } else {
        input = `
          <input type="${type}"
                 class="form-control"
                 id="${inputId}"
                 name="${name}"
                 placeholder="${label}"
                 value="${value}"
                 ${required ? 'required' : ''}
                 ${step ? `step="${step}"` : ''}
                 ${min ? `min="${min}"` : ''}
          >`;
    }

    return `
      <div class="form-group mb-3">
        <label for="${inputId}" class="form-label">${label}</label>
        ${input}
      </div>`;
};
    
    // Form templates for each operation type
    const formTemplates = {
        'facing': () => [
            formGroup('Diameter (mm)', 'diameter'),
            formGroup('Depth of Cut (mm)', 'depth_of_cut'),
            formGroup('Feed (mm/rev)', 'feed'),
            formGroup('Spindle Speed (RPM)', 'spindle_speed'),
            `<div class="form-group mt-4">
                <button type="button" 
                        class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                        onclick="calculateOperationTime('${entryId}', 'facing')">
                    <i class="fas fa-calculator"></i> Calculate Time
                </button>
                <input id="${entryId}_time" 
                       type="text" 
                       class="mt-2 block w-full p-2 border border-gray-300 rounded-md bg-gray-50" 
                       placeholder="Time (minutes)" 
                       readonly>
            </div>`
        ].join(''),
        'turning': () => [
            formGroup('Start Diameter (mm)', 'start_diameter'),
            formGroup('End Diameter (mm)', 'end_diameter'),
            formGroup('Length (mm)', 'length'),
            formGroup('Depth of Cut (mm)', 'depth_of_cut'),
            formGroup('Feed (mm/rev)', 'feed'),
            formGroup('Spindle Speed (RPM)', 'spindle_speed'),
            `<div class="form-group mt-4">
                <button type="button" 
                        class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                        onclick="calculateOperationTime('${entryId}', 'turning')">
                    <i class="fas fa-calculator"></i> Calculate Time
                </button>
                <input id="${entryId}_time" 
                       type="text" 
                       class="mt-2 block w-full p-2 border border-gray-300 rounded-md bg-gray-50" 
                       placeholder="Time (minutes)" 
                       readonly>
            </div>`
        ].join(''),
        'drilling': () => [
            formGroup('Hole Depth (mm)', 'hole_depth'),
            formGroup('Hole Diameter (mm)', 'hole_diameter'),
            formGroup('Feed (mm/rev)', 'feed'),
            formGroup('Spindle Speed (RPM)', 'spindle_speed'),
            `<div class="form-group mt-4">
                <button type="button" 
                        class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                        onclick="calculateOperationTime('${entryId}', 'drilling')">
                    <i class="fas fa-calculator"></i> Calculate Time
                </button>
                <input id="${entryId}_time" 
                       type="text" 
                       class="mt-2 block w-full p-2 border border-gray-300 rounded-md bg-gray-50" 
                       placeholder="Time (minutes)" 
                       readonly>
            </div>`
        ].join(''),
        'reaming': () => [
            formGroup('Hole Diameter (mm)', 'hole_diameter'),
            formGroup('Hole Depth (mm)', 'hole_depth'),
            formGroup('Feed (mm/rev)', 'feed'),
            formGroup('Spindle Speed (RPM)', 'spindle_speed'),
            `<div class="form-group mt-4">
                <button type="button" 
                        class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                        onclick="calculateOperationTime('${entryId}', 'reaming')">
                    <i class="fas fa-calculator"></i> Calculate Time
                </button>
                <input id="${entryId}_time" 
                       type="text" 
                       class="mt-2 block w-full p-2 border border-gray-300 rounded-md bg-gray-50" 
                       placeholder="Time (minutes)" 
                       readonly>
            </div>`
        ].join(''),
        'boring': () => [
            formGroup('Hole Diameter (mm)', 'hole_diameter'),
            formGroup('Hole Depth (mm)', 'hole_depth'),
            formGroup('Cutting Depth (mm)', 'cutting_depth'),
            formGroup('Feed (mm/rev)', 'feed'),
            formGroup('Spindle Speed (RPM)', 'spindle_speed'),
            `<div class="form-group mt-4">
                <button type="button" 
                        class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                        onclick="calculateOperationTime('${entryId}', 'boring')">
                    <i class="fas fa-calculator"></i> Calculate Time
                </button>
                <input id="${entryId}_time" 
                       type="text" 
                       class="mt-2 block w-full p-2 border border-gray-300 rounded-md bg-gray-50" 
                       placeholder="Time (minutes)" 
                       readonly>
            </div>`
        ].join(''),
        'threading': () => [
            formGroup('Thread Length (mm)', 'thread_length'),
            formGroup('Thread Pitch (mm/thread)', 'thread_pitch'),
            formGroup('Threads per Pass', 'threads_per_pass'),
            formGroup('Spindle Speed (RPM)', 'spindle_speed'),
            `<div class="form-group mt-4">
                <button type="button" 
                        class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                        onclick="calculateOperationTime('${entryId}', 'threading')">
                    <i class="fas fa-calculator"></i> Calculate Time
                </button>
                <input id="${entryId}_time" 
                       type="text" 
                       class="mt-2 block w-full p-2 border border-gray-300 rounded-md bg-gray-50" 
                       placeholder="Time (minutes)" 
                       readonly>
            </div>`
        ].join(''),
        'grooving': () => [
            formGroup('Groove Width (mm)', 'groove_width'),
            formGroup('Groove Depth (mm)', 'groove_depth'),
            formGroup('Feed (mm/rev)', 'feed'),
            formGroup('Spindle Speed (RPM)', 'spindle_speed'),
            `<div class="form-group mt-4">
                <button type="button" 
                        class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                        onclick="calculateOperationTime('${entryId}', 'grooving')">
                    <i class="fas fa-calculator"></i> Calculate Time
                </button>
                <input id="${entryId}_time" 
                       type="text" 
                       class="mt-2 block w-full p-2 border border-gray-300 rounded-md bg-gray-50" 
                       placeholder="Time (minutes)" 
                       readonly>
            </div>`
        ].join(''),
        'parting': () => [
            formGroup('Parting Diameter (mm)', 'parting_diameter'),
            formGroup('Parting Tool Width (mm)', 'tool_width'),
            formGroup('Feed (mm/rev)', 'feed'),
            formGroup('Spindle Speed (RPM)', 'spindle_speed'),
            `<div class="form-group mt-4">
                <button type="button" 
                        class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                        onclick="calculateOperationTime('${entryId}', 'parting')">
                    <i class="fas fa-calculator"></i> Calculate Time
                </button>
                <input id="${entryId}_time" 
                       type="text" 
                       class="mt-2 block w-full p-2 border border-gray-300 rounded-md bg-gray-50" 
                       placeholder="Time (minutes)" 
                       readonly>
            </div>`
        ].join(''),
        'knurling': () => [
            formGroup('Knurling Length (mm)', 'knurling_length'),
            formGroup('Workpiece Diameter (mm)', 'workpiece_diameter'),
            formGroup('Knurl Pitch (teeth per inch)', 'knurl_pitch'),
            formGroup('Spindle Speed (RPM)', 'spindle_speed'),
            `<div class="form-group mt-4">
                <button type="button" 
                        class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                        onclick="calculateOperationTime('${entryId}', 'knurling')">
                    <i class="fas fa-calculator"></i> Calculate Time
                </button>
                <input id="${entryId}_time" 
                       type="text" 
                       class="mt-2 block w-full p-2 border border-gray-300 rounded-md bg-gray-50" 
                       placeholder="Time (minutes)" 
                       readonly>
            </div>`
        ].join(''),
        'idle': () => [
            formGroup('Idle Operation Type', 'idle_type', {
                type: 'select',
                options: [
                    { value: 'tool_movement', label: 'Tool Movement' },
                    { value: 'tool_replacement', label: 'Tool Replacement' },
                    { value: 'reorient_workpiece', label: 'Reorient Workpiece' },
                    { value: 'inspection', label: 'Inspection' },
                    { value: 'load_part', label: 'Load/Unload Part' },
                    { value: 'other', label: 'Other' }
                ]
            }),
            formGroup('Idle Time (minutes)', 'idle_time', {
                type: 'number',
                step: '0.1',
                min: '0'
            }),
            `<div class="form-group mt-4">
                <button type="button"
                        class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                        onclick="calculateOperationTime('${entryId}', 'idle')">
                    <i class="fas fa-calculator"></i> Calculate Idle Time
                </button>
                <input id="${entryId}_total_time"
                       type="text"
                       class="mt-2 block w-full p-2 border border-gray-300 rounded-md bg-gray-50"
                       placeholder="Idle Time (minutes)"
                       readonly>
            </div>`
            
        ].join('')
    };
    
    // Get the form generator function for the requested operation type
    const formGenerator = formTemplates[opType];
    if (!formGenerator) {
        console.error(`No form template found for operation type: ${operationType}`);
        return '';
    }
    
    try {
        return formGenerator();
    } catch (error) {
        console.error(`Error generating form for operation ${operationType}:`, error);
        return '';
    }
}
    
function removeElement(elementOrId) {
    const element = typeof elementOrId === 'string' ? document.getElementById(elementOrId) : elementOrId;
    if (element) element.remove();
    if (typeof calculateTotalTime === 'function') calculateTotalTime();
}
// Clear all operations
function clearAll() {
    // Clear operation list
    operationList.innerHTML = '';
    
    // Reset form
    if (materialSelect) materialSelect.value = '';
    if (operationSelect) operationSelect.value = '';
    
    // Hide action buttons
    const actionButtons = document.querySelector('.action-buttons');
    if (actionButtons) {
        actionButtons.style.display = 'none';
    }
    
    // Reset time display
    document.getElementById('totalTime').textContent = '0.00';
    
    // Reset all time and cost fields
    const displayFields = [
        'setupTime', 'machiningTime', 'toolTime', 'miscTime',
        'materialCost', 'setupCost', 'nonProductiveCost',
        'machiningCost', 'toolingCost', 'totalCost', 'estimatedCost'
    ];
    
    displayFields.forEach(field => {
        const element = document.getElementById(field);
        if (element) element.textContent = '0.00';
    });
}
// Calculate the time for a single operation entry
async function calculateOperationTime(entryId, operationType) {
    try {
        const entry = document.getElementById(entryId);
        if (!entry) {
            throw new Error(`Could not find entry with ID: ${entryId}`);
        }

        const materialId = document.getElementById('materialSelect')?.value;
        if (!materialId) {
            throw new Error('Please select a material before calculating.');
        }

        // Gather all inputs for this entry
        const dimensions = {};
        entry.querySelectorAll('input[type="number"], input[type="text"], select').forEach(input => {
            if (input.name && input.value) {
                // Parse numeric inputs as float, leave others as strings
                dimensions[input.name] = isNaN(parseFloat(input.value)) 
                    ? input.value 
                    : parseFloat(input.value);
            }
        });

        // Get operation ID from the entry's dataset or ID
        const operationId = entry.dataset.operationId || entry.id.replace('process_', '');
        if (!operationId) {
            throw new Error('Could not determine operation type.');
        }

        // Prepare the payload for the API
        const payload = {
            material_id: parseInt(materialId, 10),
            operation_id: parseInt(operationId, 10),
            operation_name: operationType,
            dimensions: dimensions
        };
        
        console.log('Sending payload to /api/calculate:', payload);

        // Make the API call
        const response = await fetch('/api/calculate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        const result = await response.json();
        console.log('API Response:', result);

        // Update the UI with the result
        const timeInput = document.getElementById(`${entryId}_time`);
        if (!timeInput) {
            throw new Error('Could not find time input field.');
        }

        if (response.ok && result.status === 'success') {
            // Format time to 2 decimal places
            const timeValue = parseFloat(result.time || 0);
            timeInput.value = timeValue.toFixed(2);
            
            // Store the result data in the entry's dataset for later use
            entry.dataset.calculationResult = JSON.stringify(result.data || {});
            
            // Update any other relevant UI elements
            updateOperationResultUI(entryId, result);
            
            // Recalculate total time and cost
            calculateTotalTime();
            
            return result;
        } else {
            throw new Error(result.message || 'Failed to calculate operation time');
        }
    } catch (error) {
        console.error('Error in calculateOperationTime:', error);
        const timeInput = document.getElementById(`${entryId}_time`);
        if (timeInput) {
            timeInput.value = 'Error';
            timeInput.title = error.message || 'Calculation failed';
        }
        alert(`Error: ${error.message || 'Failed to calculate operation time'}`);
        throw error;
    }
}

// Helper function to update UI with operation results
function updateOperationResultUI(entryId, result) {
    const entry = document.getElementById(entryId);
    if (!entry || !result.data) return;

    const resultContainer = entry.querySelector('.operation-result');
    if (!resultContainer) return;

    const { time, data } = result;
    resultContainer.innerHTML = `
        <div class="p-2 bg-gray-50 rounded mt-2">
            <div class="text-sm text-gray-600">Time: ${(time || 0).toFixed(2)} min</div>
            ${data.cost ? `<div class="text-sm text-gray-600">Cost: ₹${data.cost.toFixed(2)}</div>` : ''}
        </div>
    `;
}


// Function to update miscellaneous time
function updateMiscTime() {
    const miscInput = document.getElementById('miscInput');
    if (!miscInput) return;
    
    const miscTime = parseFloat(miscInput.value) || 0;
    if (isNaN(miscTime) || miscTime < 0) {
        alert('Please enter a valid positive number for miscellaneous time');
        return;
    }
    
    // Update the display
    const miscTimeElement = document.getElementById('miscTime');
    if (miscTimeElement) {
        miscTimeElement.textContent = `${miscTime.toFixed(2)} min`;
    }
    
    // Store the value in a data attribute for persistence
    if (miscInput) {
        miscInput.dataset.currentValue = miscTime;
    }
    
    // Recalculate totals
    calculateTotalTime();
    
    // Clear the input field
    miscInput.value = '';
    
    // Show both sections if they're hidden
    const timeCostSection = document.getElementById('timeCostSection');
    const costEstimationSection = document.getElementById('costEstimationSection');
    [timeCostSection, costEstimationSection].forEach(section => {
        if (section) section.classList.add('visible');
    });
}


// Cache for setup times to avoid redundant API calls
const setupTimeCache = new Map();

// Centralized function to show/hide UI sections
function updateUISections(show = true) {
    const sections = ['timeCostSection', 'costEstimationSection']
        .map(id => document.getElementById(id))
        .filter(Boolean);
    
    sections.forEach(section => {
        section.classList.toggle('visible', show);
    });
}

/**
 * Updates the UI with calculation results from the backend
 * @param {Object} data - The response data from the backend
 */
function updateResultsUI(data) {
    // Show sections
    const timeCostSection = document.getElementById('timeCostSection');
    const costEstimationSection = document.getElementById('costEstimationSection');
    timeCostSection?.classList.add('visible');
    costEstimationSection?.classList.add('visible');

    // Update time fields
    const timeFields = {
        'setupTime': data.total_setup_time || 0,
        'idleTime': data.total_idle_time || 0,
        'machiningTime': data.total_machining_time || 0,
        'toolTime': data.total_tool_time || 0,
        'miscTime': data.misc_time || 0,
        'totalTime': data.total_time || 0
    };

    // Update cost fields
    const costFields = {
        'materialCost': data.material_cost || 0,
        'setupCost': data.setup_cost || 0,
        'nonProductiveCost': data.non_productive_cost || 0,
        'machiningCost': data.machining_cost || 0,
        'toolingCost': data.tooling_cost || 0,
        'setupIdleCost': data.setup_idle_cost || 0, // Sum of setup + idle costs
        'totalCost': data.total_cost || 0,
        'estimatedCost': data.estimated_cost || data.total_cost || 0
    };

    // Update time fields in UI
    Object.entries(timeFields).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = parseFloat(value).toFixed(2);
        }
    });

    // Update cost fields in UI
    Object.entries(costFields).forEach(([id, value]) => {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = parseFloat(value).toFixed(2);
        }
    });
}

// Function to fetch cost calculation from backend
async function fetchCostCalculation() {
    try {
        // Gather all operation data
        const operations = [];
        let totalMachiningTime = 0;
        let totalSetupTime = 0;
        let totalIdleTime = 0;
        let totalToolTime = 0;

        // Collect operation data and calculate times
        document.querySelectorAll('.operation-entry').forEach(entry => {
            const timeInput = entry.querySelector('input[type="number"][id$="_time"]');
            const idleInput = entry.querySelector('input[type="number"][id$="_idle_time"]');
            const toolInput = entry.querySelector('input[type="number"][id$="_tool_time"]');
            
            const opTime = parseFloat(timeInput?.value) || 0;
            const idleTime = parseFloat(idleInput?.value) || 0;
            const toolTime = parseFloat(toolInput?.value) || 0;
            
            operations.push({
                operation_id: entry.dataset.operationId,
                operation_time: opTime,
                idle_time: idleTime,
                tool_time: toolTime
            });
            
            totalMachiningTime += opTime;
            totalIdleTime += idleTime;
            totalToolTime += toolTime;
        });

        // Get material ID and other global inputs
        const materialId = document.getElementById('materialSelect')?.value;
        const miscTime = parseFloat(document.getElementById('miscInput')?.value) || 0;
        
        if (!materialId) {
            throw new Error('Please select a material before calculating costs');
        }

        // Prepare payload for the backend
        const payload = {
            material_id: materialId,
            operations: operations,
            total_machining_time: totalMachiningTime,
            total_setup_time: totalSetupTime,
            total_idle_time: totalIdleTime,
            total_tool_time: totalToolTime,
            misc_time: miscTime
        };

        console.log('Sending calculation request:', payload);
        
        const response = await fetch('/calculate_cost', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        console.log('Calculation result:', result);
        
        // Update the UI with the complete result
        updateResultsUI({
            ...result,
            total_machining_time: totalMachiningTime,
            total_setup_time: totalSetupTime,
            total_idle_time: totalIdleTime,
            total_tool_time: totalToolTime,
            misc_time: miscTime,
            total_time: totalMachiningTime + totalSetupTime + totalIdleTime + totalToolTime + miscTime
        });
        
        return result;
    } catch (error) {
        console.error('Error in cost calculation:', error);
        alert(`Error calculating costs: ${error.message}`);
        throw error;
    }
}

async function calculateTotalTime() {
    // Get operation entries and sections
    const operationEntries = document.querySelectorAll('.operation-entry');
    const timeCostSection = document.getElementById('timeCostSection');
    const costEstimationSection = document.getElementById('costEstimationSection');
    
    // Hide sections by default
    updateUISections(false);
    
    // Return early if no operations
    if (operationEntries.length === 0) {
        return 0;
    }

    // Time calculations
    let totalMachiningTime = 0;
    let totalIdleTime = 0;
    let totalToolTime = 0;
    let totalSetupTime = 0;
    
    // Get global idle time input if it exists
    const globalIdleInput = document.getElementById('globalIdleTime');
    if (globalIdleInput) {
        totalIdleTime = parseFloat(globalIdleInput.value) || 0;
    }
    
    // Get global tool time input if it exists
    const globalToolInput = document.getElementById('globalToolTime');
    if (globalToolInput) {
        totalToolTime = parseFloat(globalToolInput.value) || 0;
    }

    const operationIds = [];
    
    // Process each operation for machining time and collect times
    for (const entry of operationEntries) {
        const entryId = entry.id;
        
        // Get the process time input (process_X_time)
        const timeInput = entry.querySelector(`#${entryId}_time`);
        if (timeInput?.value) {
            totalMachiningTime += parseFloat(timeInput.value) || 0;
        }
        
        // Get per-operation idle time if it exists
        const idleInput = entry.querySelector(`#${entryId}_idle_time`);
        if (idleInput?.value) {
            totalIdleTime += parseFloat(idleInput.value) || 0;
        }
        
        // Get per-operation tool time if it exists
        const toolInput = entry.querySelector(`#${entryId}_tool_time`);
        if (toolInput?.value) {
            totalToolTime += parseFloat(toolInput.value) || 0;
        }
        
        // Collect operation IDs for setup time fetch
        if (entry.dataset.operationId) {
            operationIds.push(entry.dataset.operationId);
        }
    }

    // Fetch setup times in parallel with better error handling
    const setupTimePromises = operationIds.map(operationId => {
        // Skip invalid operation IDs
        if (!operationId || isNaN(parseInt(operationId))) {
            console.warn(`Invalid operation ID: ${operationId}`);
            return Promise.resolve(0);
        }
        
        if (setupTimeCache.has(operationId)) {
            return Promise.resolve(setupTimeCache.get(operationId));
        }
        
        return fetch(`/get_setup_time?operation_id=${operationId}`)
            .then(resp => {
                if (!resp.ok) throw new Error(`HTTP error! status: ${resp.status}`);
                return resp.json();
            })
            .then(data => {
                const time = parseFloat(data?.setup_time) || 0;
                setupTimeCache.set(operationId, time);
                return time;
            })
            .catch(error => {
                console.error(`Failed to fetch setup time for operation ${operationId}:`, error);
                return 0; // Return 0 if fetch fails
            });
    });
    
    // Wait for all setup times
    const setupTimes = await Promise.all(setupTimePromises);
    totalSetupTime = setupTimes.reduce((sum, time) => sum + time, 0);

    // Get miscellaneous time
    const miscTime = parseFloat(document.getElementById('miscInput')?.value) || 0;

    // Total time calculation
    const totalTime = totalMachiningTime + totalIdleTime + totalToolTime + totalSetupTime + miscTime;

    // Material weight calculation will be handled by the backend
    const materialWeight = 0; // Will be set by backend

    // Update Time UI
    const updateIfExists = (id, value, formatter = v => v) => {
        const element = document.getElementById(id);
        if (element) element.textContent = formatter(value);
    };
    
    updateIfExists('machiningTime', totalMachiningTime, v => v.toFixed(2));
    updateIfExists('idleTime', totalIdleTime, v => v.toFixed(2));
    updateIfExists('setupTime', totalSetupTime, v => v.toFixed(2));
    updateIfExists('toolTime', totalToolTime, v => v.toFixed(2));
    updateIfExists('miscTime', miscTime, v => v.toFixed(2));
    updateIfExists('totalTime', totalTime, v => v.toFixed(2));
    
    // Trigger cost calculation which will also update the UI
    try {
        await fetchCostCalculation();
    } catch (error) {
        console.error('Error in cost calculation:', error);
    }

    return {
        totalTime,
        breakdown: {
            times: {
                machining: totalMachiningTime,
                idle: totalIdleTime,
                setup: totalSetupTime,
                tool: totalToolTime,
                misc: miscTime,
                total: totalTime
            }
        }
    };
}

// Cost calculation is handled by the backend API via /calculate_cost endpoint
// The backend returns all cost-related calculations in the format:
// {
//   material_cost: number,
//   setup_cost: number,
//   non_productive_cost: number,
//   machining_cost: number,
//   tooling_cost: number,
//   setup_idle_cost: number,  // Sum of setup + idle costs
//   total_cost: number,
//   estimated_cost: number    // Same as total_cost by default
// }

// Validate form before calculation
function validateOperationForm(processId, operationType) {
    const entry = document.getElementById(processId);
    if (!entry) {
        throw new Error('Process entry not found');
    }
    
    // Check material selection
    const materialSelect = entry.querySelector(`select#material_${processId}`);
    if (!materialSelect) {
        throw new Error(`Material select element with ID 'material_${processId}' not found`);
    }
    if (!materialSelect.value) {
        throw new Error('Please select a material');
    }
    
    // Check required fields for the operation
    const opType = operationType.toLowerCase();
    const required = requiredFields[opType] || [];
    
    // Debug logging
    console.debug(`Validating ${opType}: Required = ${required.join(', ')}`);
    
    const missingFields = [];
    
    required.forEach(field => {
        const input = entry.querySelector(`#${processId}_${field}`);
        if (!input) {
            console.warn(`Input field ${field} not found for process ${processId}`);
            return;
        }
        
        // Check if value is empty but not '0'
        if (input.value === '' && input.value !== '0') {
            const label = entry.querySelector(`label[for="${processId}_${field}"]`);
            const fieldName = label ? label.textContent.replace(':', '') : field;
            missingFields.push(fieldName);
        }
    });
    
    if (missingFields.length > 0) {
        console.debug(`Missing fields: ${missingFields.join(', ')}`);
        throw new Error(`Missing required fields: ${missingFields.join(', ')}`);
    }
    
    return true;
}

// High-level wrapper — validates & shows loader
async function calculateOperation(processId, operationType) {
    const entry = document.getElementById(processId);
    if (!entry) return;

    const resultDiv = document.getElementById(`result-${processId}`);
    resultDiv.innerHTML = '<div class="alert alert-info">Calculating...</div>';

    try {
        // Validate before calling the backend
        validateOperationForm(processId, operationType);

        // Delegate to the function that does the API call
        await calculateOperationTime(processId, operationType);
    } catch (error) {
        resultDiv.innerHTML = `
            <div class="alert alert-danger"><strong>Error:</strong> ${error.message}</div>`;
        console.error(error);
    }
}

// Constants for PDF generation
const PDF_TERMS = `Terms and Conditions:
1. This is a computer-generated estimate.
2. Prices are subject to change based on material availability.
3. Minimum order quantity may apply.`;

// Export operations to PDF
async function exportToPDF(type = 'customer') {
    try {
        const { jsPDF } = window.jspdf;
        if (!jsPDF) {
            throw new Error('PDF library not loaded');
        }
        
        const doc = new jsPDF();
        const title = type === 'shop' ? 'Machine Shop Report' : 'Customer Quotation';
        
        doc.setFontSize(16);
        doc.text(title, 105, 20, { align: 'center' });
        
        // Add date
        const date = new Date().toLocaleDateString();
        doc.setFontSize(10);
        doc.text(`Date: ${date}`, 200, 15, { align: 'right' });
        
        // Add content based on type
        if (type === 'shop') {
            // Shop version - more technical details
            doc.text('Technical Details:', 14, 40);
            // Add operations list
            const operationEntries = document.querySelectorAll('.operation-entry');
            let yPos = 60;
            
            operationEntries.forEach((entry, index) => {
                const operationName = entry.querySelector('h3')?.textContent || `Operation ${index + 1}`;
                doc.text(`${index + 1}. ${operationName}`, 20, yPos);
                yPos += 10;
                
                // Add operation parameters
                const inputs = entry.querySelectorAll('input[type="number"]');
                inputs.forEach(input => {
                    if (input.value) {
                        const label = input.previousElementSibling?.textContent || 'Parameter';
                        doc.text(`   • ${label}: ${input.value}`, 25, yPos);
                        yPos += 7;
                    }
                });
                
                yPos += 5;
                
                // Add new page if needed
                if (yPos > 270) {
                    doc.addPage();
                    yPos = 20;
                }
            });
        } else {
            // Customer version - simplified
            doc.text('Quotation Details:', 14, 40);
            
            // Add customer info
            doc.setFontSize(12);
            doc.text('Customer: ________________________', 20, 60);
            doc.text('Project: _________________________', 20, 70);
            
            // Add summary
            doc.setFontSize(10);
            doc.text('Summary of Operations:', 20, 90);
            
            const operationEntries = document.querySelectorAll('.operation-entry');
            let currentY = 100;
            
            operationEntries.forEach((entry, index) => {
                const operationName = entry.querySelector('h3')?.textContent || `Operation ${index + 1}`;
                doc.text(`${index + 1}. ${operationName}`, 25, currentY);
                currentY += 7;
                
                // Add operation summary
                const opType = entry.querySelector('.operation-type')?.textContent || 'Operation';
                const time = entry.querySelector('.operation-time')?.textContent || 'N/A';
                doc.text(`- ${opType}: ${time} min`, 30, currentY);
                currentY += 7;
                
                if (currentY > 270) {
                    doc.addPage();
                    currentY = 20;
                }
            });
            
            // Add total cost
            const totalCost = document.getElementById('totalCost')?.textContent || '0.00';
            doc.setFontSize(12);
            doc.setFont(undefined, 'bold');
            doc.text(`Total Estimated Cost: ₹${totalCost}`, 20, currentY + 20);
            
            // Add terms and conditions for customer
            doc.setFontSize(10);
            doc.text(PDF_TERMS, 20, currentY + 28, { maxWidth: 180 });
        }
        
        // Save the PDF
        const filename = type === 'shop' 
            ? `Machine_Shop_Report_${new Date().getTime()}.pdf`
            : `Customer_Quote_${new Date().getTime()}.pdf`;
        
        doc.save(filename);
    } catch (error) {
        console.error('Error generating PDF:', error);
        alert('Failed to generate PDF. Please check console for details.');
    }
}
